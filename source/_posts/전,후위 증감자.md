💡 후/전위 증감 연산자의 특징과 차이점에 대해서 설명한다.


## 구문

```cpp
postfix-expression++
++unary-expression

postfix-expression--
--unary-expression
```

## 설명

증감 연산자는 피연산자에게 적절한 형식의 한 단위를 추가하거나 감소한다.

ex) long* 에 ++ 연산을 하면 4byte 만큼 뒤로 이동을 하게 된다.

전위 연산자는 값을 증감시킨 후에 expression을 실행한다

후위 연산자는 값을 증감시키기 전에 expression을 실행한다.

## 차이점

### l-value r-value

증감 연산자는 둘 다 피연산자가 한 단위만큼 추가, 감소 시키는 것이지만 결과가 차이가 날 수 있다.

예를 들어서

```cpp
int num = 10;
++num = 12;
num++ = 12; // complile error! [error C2106: '=': 왼쪽 피연산자는 l-value이어야 합니다.]
```

위의 예시를 보면 `num++ = 30` 이라는 구문의 에러를 보면 `num++` 라는 것이 `r-value` 라는 것을 확인할 수 있는데 왜 그런 걸까

전위 연산자를 사용할 때 실제 메모리가 어떻게 작동하는지 확인해보자.

아래 코드는 vs 에서 디스어셈블리로 확인한 코드이다.

```cpp
int main() {
00007FF64ACD2440  push        rbp  
00007FF64ACD2442  push        rdi  
00007FF64ACD2443  sub         rsp,108h  
00007FF64ACD244A  lea         rbp,[rsp+20h]  
00007FF64ACD244F  lea         rcx,[__6E4D752D_main@cpp (07FF64ACE306Ah)]  
00007FF64ACD2456  call        __CheckForDebuggerJustMyCode (07FF64ACD13DEh)  
	int num = 10;
00007FF64ACD245B  mov         dword ptr [num],0Ah  
	if (++num == 11) {
00007FF64ACD2462  mov         eax,dword ptr [num]  
00007FF64ACD2465  inc         eax  
00007FF64ACD2467  mov         dword ptr [num],eax  
00007FF64ACD246A  cmp         dword ptr [num],0Bh  
00007FF64ACD246E  jne         main+4Ah (07FF64ACD248Ah)  
		std::cout << num << '\n';
00007FF64ACD2470  mov         edx,dword ptr [num]  
00007FF64ACD2473  mov         rcx,qword ptr [__imp_std::cout (07FF64ACE1198h)]  
00007FF64ACD247A  call        qword ptr [__imp_std::basic_ostream<char,std::char_traits<char> >::operator<< (07FF64ACE1188h)]  
00007FF64ACD2480  mov         dl,0Ah  
00007FF64ACD2482  mov         rcx,rax  
00007FF64ACD2485  call        std::operator<<<std::char_traits<char> > (07FF64ACD1316h)  
	}

	return 0;
00007FF64ACD248A  xor         eax,eax  
}
00007FF64ACD248C  lea         rsp,[rbp+0E8h]  
00007FF64ACD2493  pop         rdi  
00007FF64ACD2494  pop         rbp  
00007FF64ACD2495  ret  
```

어셈블리에 대해서 간단한 설명을 하면

---

1. num의 메모리를 잡고 10을 대입한다.

---

1. eax register에 num 에 해당하는 값을 넣고
2. eax register 값을 1 올려준다.
3. 그리고 num 에 eax register를 저장한다.
4. 그리고 11과 num 의 값을 비교해서 점프 수행한다.

---

이 순서를 보면 결국 ++num 의 결과는 num 값에 1을 더해준 이후 num의 메모리 값을 돌려주기 때문에 결과 값이 l-value가 되게 된다.

그렇다면 후위 연산자는 어떻게 될

```cpp
int main() {
00007FF7E29D2440  push        rbp  
00007FF7E29D2442  push        rdi  
00007FF7E29D2443  sub         rsp,108h  
00007FF7E29D244A  lea         rbp,[rsp+20h]  
00007FF7E29D244F  lea         rcx,[__6E4D752D_main@cpp (07FF7E29E306Ah)]  
00007FF7E29D2456  call        __CheckForDebuggerJustMyCode (07FF7E29D13DEh)  
	int num = 10;
00007FF7E29D245B  mov         dword ptr [num],0Ah  
	if (num++ == 11) {
00007FF7E29D2462  mov         eax,dword ptr [num]  
00007FF7E29D2465  mov         dword ptr [rbp+0D4h],eax  
00007FF7E29D246B  mov         eax,dword ptr [num]  
00007FF7E29D246E  inc         eax  
00007FF7E29D2470  mov         dword ptr [num],eax  
00007FF7E29D2473  cmp         dword ptr [rbp+0D4h],0Bh  
00007FF7E29D247A  jne         main+48h (07FF7E29D2488h)  
00007FF7E29D247C  mov         dword ptr [rbp+0D8h],1  
00007FF7E29D2486  jmp         main+52h (07FF7E29D2492h)  
00007FF7E29D2488  mov         dword ptr [rbp+0D8h],0  
00007FF7E29D2492  cmp         dword ptr [rbp+0D8h],0  
00007FF7E29D2499  je          main+75h (07FF7E29D24B5h)  
		std::cout << num << '\n';
00007FF7E29D249B  mov         edx,dword ptr [num]  
00007FF7E29D249E  mov         rcx,qword ptr [__imp_std::cout (07FF7E29E1198h)]  
00007FF7E29D24A5  call        qword ptr [__imp_std::basic_ostream<char,std::char_traits<char> >::operator<< (07FF7E29E1188h)]  
00007FF7E29D24AB  mov         dl,0Ah  
00007FF7E29D24AD  mov         rcx,rax  
00007FF7E29D24B0  call        std::operator<<<std::char_traits<char> > (07FF7E29D1316h)  
	}

	return 0;
00007FF7E29D24B5  xor         eax,eax  
}
00007FF7E29D24B7  lea         rsp,[rbp+0E8h]  
00007FF7E29D24BE  pop         rdi  
00007FF7E29D24BF  pop         rbp  
00007FF7E29D24C0  ret  
```

조금 길어졌는데 하나씩 살펴보자.

---

1. num의 메모리에 10 값을 대입한다.

---

1. num 값을 eax register에 대입한다.
2. eax 값을 rbp + 0x0D4 에 해당하는 위치에 복사한다.
3. eax에 num 값을 다시 복사하고
4. eax를 1 더해준다.
5. num에 eax 값을 저장한다.
6. 비교는 rdp+0x0D4 에 해당하는 값과 11을 비교해서 같은지 비교한다.

---

이처럼 num++ 의 결과 값은 rbp + 0x0D4 에 해당하는 값으로 실제 메모리를 가진 것이 아닌 r-value를 가지고 있음을 확인할 수 있다.

즉 temp = num; 으로 복사를 해놓은 다음 num += 1 을 한 다음 모든 값을 temp 로 사용하는 것이다.

또 다른 예시로 vector iterator 의 예시를 보자

```cpp
_CONSTEXPR20 _Vector_iterator& operator++() noexcept {
    _Mybase::operator++();
    return *this;
}

_CONSTEXPR20 _Vector_iterator operator++(int) noexcept {
    _Vector_iterator _Tmp = *this;
    _Mybase::operator++();
    return _Tmp;
}
```

위의 코드는 operator++ 를 정의하는 코드이고 실제로 후위 연산자는 _Tmp 를 반환하므로 l-value 가 아닌 r-value로 작동하는 것을 알 수 있다.

### 그럼 어느 것이 더 나은가?

사실 큰 차이는 없겠지만 구현에서의 문제가 조금 있을 수 있겠다.

일반적으로 후위 연산자가 더 복잡하기 때문에 똑같다면 조금이라도 적은 연산을 하는 전위 연산자를 취하는 것이 조금이라도 빠르게 작동할 수 있는 방법일 것이다.

(아무래도 컴파일러 단에서 알아서 최적화가 될 것 같긴 하다)

```cpp
	for (int i = 0; i < 5; i++) {
00007FF658FF232E  mov         dword ptr [rbp+44h],0  
00007FF658FF2335  jmp         __$EncStackInitStart+6Fh (07FF658FF233Fh)  
00007FF658FF2337  mov         eax,dword ptr [rbp+44h]  
00007FF658FF233A  inc         eax  
00007FF658FF233C  mov         dword ptr [rbp+44h],eax  
00007FF658FF233F  cmp         dword ptr [rbp+44h],5  
00007FF658FF2343  jge         __$EncStackInitStart+9Ch (07FF658FF236Ch)  
```

```cpp
	for (int i = 0; i < 5; ++i) {
00007FF6B856232E  mov         dword ptr [rbp+44h],0  
00007FF6B8562335  jmp         __$EncStackInitStart+6Fh (07FF6B856233Fh)  
00007FF6B8562337  mov         eax,dword ptr [rbp+44h]  
00007FF6B856233A  inc         eax  
00007FF6B856233C  mov         dword ptr [rbp+44h],eax  
00007FF6B856233F  cmp         dword ptr [rbp+44h],5  
00007FF6B8562343  jge         __$EncStackInitStart+9Ch (07FF6B856236Ch)  
```

(실제로 되는 듯 하다…)

### 헷갈리는 예시들

```cpp
int strcmp(const char* str1, const char* str2) {
	while (*str1 && *str1++ == *str2++);
	return *str1 - *str2;
}
```

위의 예시를 보면 *str1++ 이건 어떻게 작동될까?

위의 설명을 봤을 때 우선순위에 의해서 ++ 가 먼저 작동되고 * 가 작동된다.

1. str1 += 1 를 한다.
2. str1 원래 값을 * 연산자로 접근
3. str2 += 1 를 한다.
4. str2 원래 값을 * 연산자로 접근

[C++ 기본 제공 연산자, 우선 순위 및 결합성 | Microsoft Learn](https://learn.microsoft.com/ko-kr/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170)

즉 저 함수는 제대로 작동하는 것이 맞다.